<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player HLS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 28px;
        }

        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #hlsPlayerWrapper {
            width: 100%;
        }

        #externalPlayerContainer {
            display: none;
            flex-direction: column;
            width: 100%;
            min-height: 400px;
            background: #000;
        }

        #externalPlayerFrame {
            width: 100%;
            min-height: 480px;
            border: none;
            background: #000;
        }

        .external-player-alert {
            padding: 15px;
            color: #fff;
            text-align: center;
            background: rgba(255, 255, 255, 0.08);
        }

        .external-player-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.85);
        }

        .external-player-actions button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }

        .episode-title-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        video {
            width: 100%;
            height: auto;
            display: block;
        }

        .video-controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border-radius: 0 0 10px 10px;
        }

        .progress-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #progressSlider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #progressSlider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        #progressSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: transform 0.2s;
        }

        #progressSlider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .progress-time {
            color: white;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            min-width: 100px;
            text-align: right;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }

        .control-btn {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            min-width: 50px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .watched-btn {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .watched-btn:hover {
            background: rgba(76, 175, 80, 0.5);
        }

        .watched-btn.active {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4caf50;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .quality-control {
            position: relative;
        }

        .quality-menu {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.95);
            border-radius: 6px;
            padding: 8px 0;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
        }

        .quality-option {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .quality-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .quality-option.active {
            background: rgba(102, 126, 234, 0.5);
            font-weight: 600;
        }

        #volumeSlider {
            width: 100px;
            height: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        #volumeSlider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        .status.warning {
            background: #fff3e0;
            color: #f57c00;
        }

        .video-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .info-card {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .info-card label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .info-card span {
            display: block;
            font-size: 18px;
            color: #333;
            font-weight: 700;
        }

        .history-item {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            border-left: 4px solid transparent;
        }

        .history-item.watched {
            background: linear-gradient(90deg, #e8f5e9 0%, #ffffff 5%);
            border-left-color: #4caf50;
        }

        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .watched-badge {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .history-item-info {
            flex: 1;
            min-width: 0;
        }

        .history-item-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .history-item-meta {
            font-size: 15px;
            color: #666;
            margin-bottom: 8px;
        }

        .history-item-link {
            font-size: 14px;
            color: #667eea;
            text-decoration: none;
            display: inline-block;
            margin-top: 8px;
            word-break: break-all;
            font-weight: 500;
        }

        .history-item-link:hover {
            text-decoration: underline;
            color: #764ba2;
        }

        .history-item-actions {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        .history-item-actions button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .history-empty {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Player AnimeRoll</h1>
        
        <div class="controls" style="margin-bottom: 20px;">
            <div class="input-group">
                <input 
                    type="text" 
                    id="anrollInput" 
                    placeholder="Cole o link (anroll.net ou animesonlinecc.to)"
                >
                <button id="extractBtn">Extrair Link</button>
            </div>
        </div>
        
        <div class="video-container">
            <div id="hlsPlayerWrapper">
                <video id="video"></video>
                <div class="video-controls">
                    <div class="progress-container">
                        <input type="range" id="progressSlider" min="0" max="100" value="0" step="0.1" title="Progresso do v√≠deo">
                        <div class="progress-time">
                            <span id="currentTimeDisplay">00:00</span> / <span id="durationDisplay">00:00</span>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button id="rewindBtn" class="control-btn" title="Voltar 10 segundos">‚è™ -10s</button>
                        <button id="playPauseBtn" class="control-btn" title="Play/Pause">‚è∏Ô∏è</button>
                        <button id="forwardBtn" class="control-btn" title="Avan√ßar 10 segundos">+10s ‚è©</button>
                        <div class="volume-control">
                            <button id="muteBtn" class="control-btn" title="Mutar/Desmutar">üîä</button>
                            <input type="range" id="volumeSlider" min="0" max="100" value="100" title="Volume">
                        </div>
                        <div class="quality-control">
                            <button id="qualityBtn" class="control-btn" title="Qualidade">‚öôÔ∏è Qualidade</button>
                            <div id="qualityMenu" class="quality-menu" style="display: none;">
                                <div class="quality-option" data-quality="auto">Auto</div>
                            </div>
                        </div>
                        <button id="markWatchedBtn" class="control-btn watched-btn" title="Marcar como assistido">‚úì Assistido</button>
                        <button id="fullscreenBtn" class="control-btn" title="Tela cheia">‚õ∂</button>
                    </div>
                </div>
            </div>
            <div id="externalPlayerContainer">
                <div class="external-player-alert">
                    Player externo do Blogger detectado. Use o player abaixo ou abra em uma nova aba.
                </div>
                <iframe id="externalPlayerFrame" allowfullscreen referrerpolicy="no-referrer"></iframe>
                <div class="external-player-actions">
                    <button id="openExternalBtn">Abrir player em nova aba</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="input-group">
                <input 
                    type="text" 
                    id="urlInput" 
                    placeholder="Cole a URL do arquivo .m3u8 aqui"
                    value="https://cdn-zenitsu-2-gamabunta.b-cdn.net/cf/hls/animes/mugen-gacha/007.mp4/media-1/stream.m3u8"
                >
                <button id="loadBtn">Carregar V√≠deo</button>
            </div>
        </div>

        <div id="status" class="status info" style="display: none;"></div>

        <div id="episodeTitle" class="episode-title-info" style="display: none;"></div>

        <div class="video-info">
            <div class="info-card">
                <label>Status</label>
                <span id="statusText">Aguardando...</span>
            </div>
            <div class="info-card">
                <label>Qualidade</label>
                <span id="qualityText">-</span>
            </div>
            <div class="info-card">
                <label>Dura√ß√£o</label>
                <span id="durationText">-</span>
            </div>
            <div class="info-card">
                <label>Tempo Atual</label>
                <span id="currentTimeText">00:00</span>
            </div>
        </div>

        <div class="history-section" style="margin-top: 30px;">
            <h2 style="color: #333; margin-bottom: 15px; font-size: 20px;">üìö Hist√≥rico de Epis√≥dios</h2>
            <div id="historyList" style="max-height: 600px; overflow-y: auto; background: #f5f5f5; border-radius: 8px; padding: 15px;">
                <p style="text-align: center; color: #666; padding: 20px;">Carregando hist√≥rico...</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        let hls = null;
        let currentStreamUrl = null;
        let currentTitle = null;
        let saveProgressInterval = null;
        let externalPlayerActive = false;
        let externalPlayerUrl = null;
        let currentSourceUrl = null;
        let currentPlayerUrl = null;
        let currentEpisodeId = null;
        const video = document.getElementById('video');
        const urlInput = document.getElementById('urlInput');
        const anrollInput = document.getElementById('anrollInput');
        const extractBtn = document.getElementById('extractBtn');
        const loadBtn = document.getElementById('loadBtn');
        const statusDiv = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const qualityText = document.getElementById('qualityText');
        const durationText = document.getElementById('durationText');
        const currentTimeText = document.getElementById('currentTimeText');
        const historyList = document.getElementById('historyList');
        const progressSlider = document.getElementById('progressSlider');
        const episodeTitleDiv = document.getElementById('episodeTitle');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');
        const durationDisplay = document.getElementById('durationDisplay');
        const rewindBtn = document.getElementById('rewindBtn');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const muteBtn = document.getElementById('muteBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const markWatchedBtn = document.getElementById('markWatchedBtn');
        const qualityBtn = document.getElementById('qualityBtn');
        const qualityMenu = document.getElementById('qualityMenu');
        const hlsPlayerWrapper = document.getElementById('hlsPlayerWrapper');
        const externalPlayerContainer = document.getElementById('externalPlayerContainer');
        const externalPlayerFrame = document.getElementById('externalPlayerFrame');
        const openExternalBtn = document.getElementById('openExternalBtn');
        const videoControls = document.querySelector('.video-controls');

        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        function updateVideoInfo() {
            if (video.readyState >= 2) {
                const duration = video.duration;
                if (duration && !isNaN(duration)) {
                    const minutes = Math.floor(duration / 60);
                    const seconds = Math.floor(duration % 60);
                    durationText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    durationDisplay.textContent = formatTime(duration);
                }
            }

            const current = video.currentTime;
            const minutes = Math.floor(current / 60);
            const seconds = Math.floor(current % 60);
            currentTimeText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            currentTimeDisplay.textContent = formatTime(current);
            
            // Atualizar slider de progresso (apenas se n√£o estiver arrastando)
            if (!isDraggingProgress && video.duration && !isNaN(video.duration)) {
                const progress = (video.currentTime / video.duration) * 100;
                progressSlider.value = progress;
            }
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function normalizeIdentifier(url) {
            if (!url) return null;
            try {
                return url.trim().replace(/\/+$/, '');
            } catch (error) {
                return url;
            }
        }

        function normalizeUrlValue(url) {
            if (!url) return '';
            try {
                return url.trim().replace(/\/+$/, '');
            } catch (error) {
                return url || '';
            }
        }

        function showHlsPlayer() {
            externalPlayerActive = false;
            externalPlayerUrl = null;
            currentPlayerUrl = null;
            if (externalPlayerFrame) {
                externalPlayerFrame.src = '';
            }
            externalPlayerContainer.style.display = 'none';
            hlsPlayerWrapper.style.display = 'block';
            if (videoControls) {
                videoControls.style.display = 'flex';
            }
            markWatchedBtn.disabled = false;
        }

        function loadExternalPlayer(url, title) {
            stopSavingProgress();
            if (hls) {
                hls.destroy();
                hls = null;
            }
            video.pause();
            video.removeAttribute('src');
            video.load();
            externalPlayerActive = true;
            externalPlayerUrl = url;
            currentPlayerUrl = url;
            currentEpisodeId = normalizeIdentifier(url);
            hlsPlayerWrapper.style.display = 'none';
            externalPlayerContainer.style.display = 'flex';
            if (externalPlayerFrame) {
                externalPlayerFrame.src = url;
            }
            if (videoControls) {
                videoControls.style.display = 'none';
            }
            markWatchedBtn.disabled = true;
            markWatchedBtn.classList.remove('active');
            currentStreamUrl = null;
            qualityText.textContent = '-';
            qualityBtn.textContent = '‚öôÔ∏è Qualidade';
            qualityMenu.style.display = 'none';
            durationText.textContent = '-';
            currentTimeText.textContent = '00:00';
            currentTimeDisplay.textContent = '00:00';
            durationDisplay.textContent = '00:00';
            progressSlider.value = 0;
            statusText.textContent = 'Player externo';
            if (title) {
                currentTitle = title;
                episodeTitleDiv.textContent = title;
                episodeTitleDiv.style.display = 'block';
            } else {
                episodeTitleDiv.style.display = 'none';
            }
            showStatus('Player do Blogger carregado! Use o bot√£o abaixo para abrir em nova aba, se preferir.', 'info');
            saveExternalEpisodeEntry();
        }

        if (openExternalBtn) {
            openExternalBtn.addEventListener('click', () => {
                if (externalPlayerUrl) {
                    window.open(externalPlayerUrl, '_blank', 'noopener,noreferrer');
                }
            });
        }

        async function saveExternalEpisodeEntry() {
            if (!externalPlayerUrl) return;
            const episodeId = normalizeIdentifier(currentEpisodeId || externalPlayerUrl);
            if (!episodeId) return;
            
            const entry = {
                streamUrl: normalizeUrlValue(externalPlayerUrl),
                playerUrl: normalizeUrlValue(externalPlayerUrl),
                title: currentTitle || episodeTitleDiv.textContent || 'Epis√≥dio',
                currentTime: 0,
                duration: 0,
                anrollUrl: currentSourceUrl ? normalizeUrlValue(currentSourceUrl) : (anrollInput.value ? normalizeUrlValue(anrollInput.value) : null),
                watched: false,
                playerType: 'blogger',
                episodeId
            };

            try {
                await fetch('/api/history', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(entry)
                });
                loadHistory();
            } catch (error) {
                console.error('Erro ao salvar epis√≥dio externo:', error);
            }
        }

        function loadVideo() {
            const url = urlInput.value.trim();
            
            if (!url) {
                showStatus('Por favor, insira uma URL v√°lida', 'error');
                return;
            }

            if (!url.endsWith('.m3u8')) {
                showStatus('A URL deve ser um arquivo .m3u8', 'warning');
            }

            showHlsPlayer();
            markWatchedBtn.disabled = false;
            currentPlayerUrl = null;
            currentEpisodeId = normalizeIdentifier(url);

            // Atualizar URL de origem (link usado para chegar ao stream), se houver
            const sourceFromInput = anrollInput.value.trim();
            if (sourceFromInput) {
                currentSourceUrl = sourceFromInput;
            } else if (!currentSourceUrl) {
                currentSourceUrl = null;
            }

            // Parar de salvar progresso do v√≠deo anterior
            stopSavingProgress();
            
            // Salvar progresso do v√≠deo anterior ANTES de atualizar currentStreamUrl
            // Isso garante que salvamos com a URL correta do v√≠deo anterior
            if (currentStreamUrl && video.duration) {
                saveProgress(); // Salvar uma √∫ltima vez do v√≠deo anterior
            }

            // Limpar inst√¢ncia anterior
            if (hls) {
                hls.destroy();
                hls = null;
            }

            // Atualizar URL e t√≠tulo atual para o NOVO v√≠deo
            // IMPORTANTE: Fazer isso DEPOIS de salvar o progresso do v√≠deo anterior
            currentStreamUrl = url;
            currentPlayerUrl = null;
            currentEpisodeId = normalizeIdentifier(url);
            
            // SEMPRE tentar extrair n√∫mero do epis√≥dio da URL atual primeiro
            // Isso garante que o t√≠tulo sempre corresponde ao v√≠deo sendo carregado
            const urlMatch = url.match(/\/(\d{3,4})\.mp4/i);
            if (urlMatch) {
                // Se encontrou n√∫mero na URL, SEMPRE usar ele (sobrescreve t√≠tulo anterior)
                const episodeNum = urlMatch[1];
                // Se j√° temos um t√≠tulo completo do hist√≥rico, tentar preservar o nome do anime
                if (currentTitle && currentTitle.includes(' - ')) {
                    // Extrair nome do anime do t√≠tulo anterior
                    const parts = currentTitle.split(' - ');
                    if (parts.length > 1) {
                        currentTitle = `Epis√≥dio ${episodeNum} - ${parts.slice(1).join(' - ')}`;
                    } else {
                        currentTitle = `Epis√≥dio ${episodeNum}`;
                    }
                } else {
                    currentTitle = `Epis√≥dio ${episodeNum}`;
                }
            } else if (!currentTitle) {
                // Se n√£o encontrou n√∫mero e n√£o tem t√≠tulo, usar fallback
                currentTitle = anrollInput.value.trim() || url.split('/').pop() || 'Epis√≥dio';
            }
            // Se ainda n√£o tem t√≠tulo v√°lido, tentar do anrollInput
            if (!currentTitle || currentTitle === 'Epis√≥dio') {
                if (anrollInput.value.trim()) {
                    currentTitle = anrollInput.value.trim();
                }
            }
            
            // Atualizar display do t√≠tulo
            if (currentTitle && currentTitle !== 'Epis√≥dio') {
                episodeTitleDiv.textContent = currentTitle;
                episodeTitleDiv.style.display = 'block';
            } else {
                episodeTitleDiv.style.display = 'none';
            }

            showStatus('Carregando v√≠deo...', 'info');
            statusText.textContent = 'Carregando...';
            loadBtn.disabled = true;

            // Usar hls.js para todos os navegadores (incluindo Safari) para garantir headers corretos
            if (Hls.isSupported()) {
                // Fun√ß√£o para converter URL para usar o proxy
                function getProxyUrl(originalUrl) {
                    // Se j√° est√° usando proxy, retornar como est√°
                    if (originalUrl.startsWith('/proxy/') || originalUrl.startsWith('http://localhost') || originalUrl.startsWith(window.location.origin)) {
                        return originalUrl;
                    }
                    // Converter URL para passar pelo proxy
                    return window.location.origin + '/proxy/' + encodeURIComponent(originalUrl);
                }

                // Criar loader customizado que intercepta todas as URLs
                class ProxyLoader extends Hls.DefaultConfig.loader {
                    load(context, config, callbacks) {
                        // Interceptar e converter URL para usar proxy
                        if (context.url && !context.url.startsWith('/proxy/') && !context.url.startsWith(window.location.origin)) {
                            const originalUrl = context.url;
                            context.url = getProxyUrl(originalUrl);
                            console.log('Convertendo URL:', originalUrl, '->', context.url);
                        }
                        // Chamar o loader padr√£o
                        return super.load(context, config, callbacks);
                    }
                }

                // Configurar hls.js para usar proxy (que adiciona headers server-side)
                hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: false,
                    backBufferLength: 90,
                    loader: ProxyLoader,
                    xhrSetup: function(xhr, requestUrl) {
                        // N√£o precisamos adicionar headers aqui, o proxy faz isso server-side
                        // Mas podemos adicionar headers que o navegador permite
                        xhr.setRequestHeader('Accept-Language', 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7');
                    }
                });

                // Converter a URL inicial para usar o proxy
                const proxyUrl = getProxyUrl(url);
                console.log('URL original:', url);
                console.log('URL do proxy:', proxyUrl);
                hls.loadSource(proxyUrl);
                hls.attachMedia(video);

                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    showStatus('V√≠deo carregado com sucesso!', 'success');
                    statusText.textContent = 'Pronto';
                    loadBtn.disabled = false;
                    
                    // Iniciar salvamento de progresso
                    startSavingProgress();
                    
                    // Atualizar informa√ß√µes de qualidade e criar menu
                    updateQualityMenu();
                    
                    // Atualizar informa√ß√µes de qualidade no card
                    if (hls.levels && hls.levels.length > 0) {
                        const levels = hls.levels.map(level => {
                            const height = level.height || '?';
                            const bitrate = level.bitrate ? `${Math.round(level.bitrate / 1000)}kbps` : '?';
                            return `${height}p (${bitrate})`;
                        });
                        qualityText.textContent = levels.join(', ');
                    }
                });

                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error('Erro HLS:', data);
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                // Verificar se √© erro de CORS (status 0 ou 403)
                                if (data.details === 'manifestLoadError' || data.response?.code === 0 || data.response?.code === 403) {
                                    showStatus('Erro de CORS ou acesso negado. Certifique-se de que est√° usando um servidor HTTP (n√£o file://).', 'error');
                                    statusText.textContent = 'Erro CORS';
                                } else {
                                    showStatus('Erro de rede. Tentando recuperar...', 'error');
                                    hls.startLoad();
                                }
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                showStatus('Erro de m√≠dia. Tentando recuperar...', 'error');
                                hls.recoverMediaError();
                                break;
                            default:
                                showStatus('Erro fatal: ' + (data.details || 'Erro desconhecido'), 'error');
                                statusText.textContent = 'Erro';
                                loadBtn.disabled = false;
                                break;
                        }
                    } else {
                        console.warn('Erro n√£o fatal:', data);
                    }
                });

                hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
                    const level = hls.levels[data.level];
                    if (level) {
                        const quality = level.height ? `${level.height}p` : 'Auto';
                        qualityText.textContent = quality;
                    }
                    updateQualityMenu(); // Atualizar menu quando qualidade mudar
                });
            } else {
                showStatus('Seu navegador n√£o suporta reprodu√ß√£o HLS', 'error');
                statusText.textContent = 'N√£o suportado';
                loadBtn.disabled = false;
            }

            // Eventos do v√≠deo
            video.addEventListener('loadedmetadata', function() {
                updateVideoInfo();
            });

            video.addEventListener('timeupdate', function() {
                updateVideoInfo();
            });

            video.addEventListener('play', function() {
                statusText.textContent = 'Reproduzindo';
            });

            video.addEventListener('pause', function() {
                statusText.textContent = 'Pausado';
            });

            video.addEventListener('ended', function() {
                statusText.textContent = 'Finalizado';
            });

            video.addEventListener('error', function(e) {
                showStatus('Erro ao carregar o v√≠deo', 'error');
                statusText.textContent = 'Erro';
                loadBtn.disabled = false;
            });
        }

        // Fun√ß√£o para extrair link do stream do anroll.net
        async function extractStreamUrl() {
            const anrollUrl = anrollInput.value.trim();
            
            if (!anrollUrl) {
                showStatus('Por favor, insira um link suportado (anroll.net ou animesonlinecc.to)', 'error');
                return;
            }

            const supportedDomains = ['anroll.net', 'animesonlinecc.to'];
            const isSupported = supportedDomains.some(domain => anrollUrl.includes(domain));
            if (!isSupported) {
                showStatus('O link deve ser do anroll.net ou do animesonlinecc.to', 'error');
                return;
            }

            extractBtn.disabled = true;
            extractBtn.textContent = 'Extraindo...';
            showStatus('Extraindo link do stream...', 'info');

            try {
                const response = await fetch(`/extract?url=${encodeURIComponent(anrollUrl)}`);
                const data = await response.json();

                if (data.success && data.streamUrl) {
                    currentSourceUrl = anrollUrl;
                    if (data.playerType === 'blogger') {
                        loadExternalPlayer(data.streamUrl, data.title);
                        showStatus('Player do Blogger encontrado e carregado!', 'success');
                        return;
                    }

                    urlInput.value = data.streamUrl;
                    // Usar t√≠tulo extra√≠do da p√°gina ou fallback
                    if (data.title) {
                        currentTitle = data.title;
                        episodeTitleDiv.textContent = data.title;
                        episodeTitleDiv.style.display = 'block';
                    } else {
                        // Tentar extrair n√∫mero do epis√≥dio da URL do stream
                        const streamMatch = data.streamUrl.match(/\/(\d{3,4})\.mp4/i);
                        if (streamMatch) {
                            currentTitle = `Epis√≥dio ${streamMatch[1]}`;
                        } else {
                            // Extrair t√≠tulo da URL do anroll como fallback
                            const urlMatch = anrollUrl.match(/\/watch\/e\/([^\/]+)/);
                            currentTitle = urlMatch ? `Epis√≥dio ${urlMatch[1]}` : 'Epis√≥dio';
                        }
                        episodeTitleDiv.textContent = currentTitle;
                        episodeTitleDiv.style.display = 'block';
                    }
                    showStatus('Link extra√≠do com sucesso!', 'success');
                    // Opcional: carregar automaticamente o v√≠deo
                    setTimeout(() => {
                        loadVideo();
                    }, 500);
                } else {
                    showStatus(data.error || 'N√£o foi poss√≠vel extrair o link', 'error');
                }
            } catch (error) {
                console.error('Erro ao extrair link:', error);
                showStatus('Erro ao extrair o link: ' + error.message, 'error');
            } finally {
                extractBtn.disabled = false;
                extractBtn.textContent = 'Extrair Link';
            }
        }

        // Extrair link ao clicar no bot√£o
        extractBtn.addEventListener('click', extractStreamUrl);

        // Extrair link ao pressionar Enter no input do anroll
        anrollInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                extractStreamUrl();
            }
        });

        // Carregar v√≠deo ao clicar no bot√£o
        loadBtn.addEventListener('click', loadVideo);

        // Carregar v√≠deo ao pressionar Enter no input
        urlInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loadVideo();
            }
        });

        // Fun√ß√µes de hist√≥rico
        async function loadHistory() {
            try {
                const response = await fetch('/api/history');
                const history = await response.json();
                renderHistory(history);
            } catch (error) {
                console.error('Erro ao carregar hist√≥rico:', error);
                historyList.innerHTML = '<p class="history-empty">Erro ao carregar hist√≥rico</p>';
            }
        }

        function renderHistory(history) {
            if (!history || history.length === 0) {
                historyList.innerHTML = '<p class="history-empty">Nenhum epis√≥dio assistido ainda</p>';
                return;
            }

            historyList.innerHTML = history.map((item, index) => {
                const date = new Date(item.lastWatched);
                const dateStr = date.toLocaleDateString('pt-BR', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const timeStr = formatTime(item.currentTime || 0);
                const durationStr = item.duration ? formatTime(item.duration) : '?';
                const progress = item.duration ? Math.round((item.currentTime / item.duration) * 100) : 0;
                const titleEscaped = (item.title || 'Epis√≥dio sem t√≠tulo').replace(/"/g, '&quot;');
                const anrollUrlEscaped = item.anrollUrl ? item.anrollUrl.replace(/"/g, '&quot;') : '';
                const isWatched = item.watched === true;
                
                return `
                    <div class="history-item ${isWatched ? 'watched' : ''}">
                        <div class="history-item-info">
                            <div class="history-item-title">
                                ${titleEscaped}
                                ${isWatched ? '<span class="watched-badge">‚úì Assistido</span>' : ''}
                            </div>
                            <div class="history-item-meta">
                                ${timeStr} / ${durationStr} (${progress}%) ‚Ä¢ ${dateStr}
                            </div>
                            ${item.anrollUrl ? `<a href="${anrollUrlEscaped}" target="_blank" class="history-item-link" title="Abrir no anroll.net">üîó ${anrollUrlEscaped}</a>` : ''}
                        </div>
                        <div class="history-item-actions">
                            <button onclick="resumeEpisode(${index})">‚ñ∂ Retomar</button>
                            ${!isWatched ? `<button onclick="markAsWatched(${index})" style="background: #4caf50; color: white; border: none;">‚úì Marcar Assistido</button>` : `<button onclick="unmarkAsWatched(${index})" style="background: #ff9800; color: white; border: none;">‚úó Desmarcar</button>`}
                            <button onclick="deleteEpisode(${index})" style="background: #f44336; color: white; border: none;" title="Excluir do hist√≥rico">üóëÔ∏è Excluir</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Armazenar hist√≥rico globalmente para acesso nas fun√ß√µes
            window.historyData = history;
        }

        async function saveProgress() {
            if (externalPlayerActive) return;
            if (!currentStreamUrl || !video.duration) return;
            const episodeId = normalizeIdentifier(currentEpisodeId || currentStreamUrl);
            if (!episodeId) return;
            
            const entry = {
                streamUrl: normalizeUrlValue(currentStreamUrl),
                playerUrl: currentPlayerUrl ? normalizeUrlValue(currentPlayerUrl) : null,
                title: currentTitle || urlInput.value || 'Epis√≥dio',
                currentTime: video.currentTime,
                duration: video.duration,
                anrollUrl: currentSourceUrl ? normalizeUrlValue(currentSourceUrl) : null,
                watched: false, // Manter o status de assistido separado
                playerType: 'hls',
                episodeId
            };

            try {
                const response = await fetch('/api/history');
                const history = await response.json();
                
                const existingItem = history.find(h => normalizeUrlValue(h.episodeId || h.streamUrl || h.playerUrl) === episodeId);
                
                // Preservar o status de assistido se j√° existir
                if (existingItem && existingItem.watched) {
                    entry.watched = true;
                }
                
                await fetch('/api/history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(entry)
                });
                // Atualizar lista de hist√≥rico ap√≥s salvar
                loadHistory();
            } catch (error) {
                console.error('Erro ao salvar progresso:', error);
            }
        }

        async function markAsWatched(index) {
            const item = window.historyData[index];
            if (!item) return;
            
            // Preservar a data original
            const entry = {
                ...item,
                watched: true,
                lastWatched: item.lastWatched // Manter a data original
            };

            try {
                await fetch('/api/history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(entry)
                });
                loadHistory();
                showStatus('Epis√≥dio marcado como assistido!', 'success');
            } catch (error) {
                console.error('Erro ao marcar como assistido:', error);
                showStatus('Erro ao marcar como assistido', 'error');
            }
        }

        async function unmarkAsWatched(index) {
            const item = window.historyData[index];
            if (!item) return;
            
            // Preservar a data original
            const entry = {
                ...item,
                watched: false,
                lastWatched: item.lastWatched // Manter a data original
            };

            try {
                await fetch('/api/history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(entry)
                });
                loadHistory();
                showStatus('Epis√≥dio desmarcado como assistido', 'info');
            } catch (error) {
                console.error('Erro ao desmarcar como assistido:', error);
                showStatus('Erro ao desmarcar como assistido', 'error');
            }
        }

        async function deleteEpisode(index) {
            const item = window.historyData[index];
            if (!item) return;
            
            // Confirmar exclus√£o
            if (!confirm(`Tem certeza que deseja excluir "${item.title || 'Epis√≥dio sem t√≠tulo'}" do hist√≥rico?`)) {
                return;
            }

            try {
                // Enviar tanto streamUrl quanto anrollUrl para garantir que encontre a entrada correta
                const deleteData = {
                    streamUrl: item.streamUrl,
                    playerUrl: item.playerUrl || null,
                    episodeId: item.episodeId || item.streamUrl || item.playerUrl || null
                };
                if (item.anrollUrl) {
                    deleteData.anrollUrl = item.anrollUrl;
                }
                
                const response = await fetch('/api/history', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(deleteData)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    loadHistory();
                    showStatus('Epis√≥dio exclu√≠do do hist√≥rico', 'success');
                } else {
                    showStatus(data.error || 'Erro ao excluir epis√≥dio', 'error');
                }
            } catch (error) {
                console.error('Erro ao excluir epis√≥dio:', error);
                showStatus('Erro ao excluir epis√≥dio', 'error');
            }
        }

        function startSavingProgress() {
            // Limpar intervalo anterior
            if (saveProgressInterval) {
                clearInterval(saveProgressInterval);
            }
            
            // Salvar progresso a cada 5 segundos
            saveProgressInterval = setInterval(() => {
                if (video.currentTime > 0 && video.duration) {
                    saveProgress();
                }
            }, 5000);
        }

        function stopSavingProgress() {
            if (saveProgressInterval) {
                clearInterval(saveProgressInterval);
                saveProgressInterval = null;
            }
        }

        function resumeEpisode(index) {
            const item = window.historyData[index];
            if (!item) return;
            showHlsPlayer();
            if (item.playerType && item.playerType !== 'hls') {
                if (item.anrollUrl) {
                    anrollInput.value = item.anrollUrl;
                }
                currentSourceUrl = item.anrollUrl || null;
                currentEpisodeId = normalizeIdentifier(item.episodeId || item.playerUrl || item.streamUrl || item.anrollUrl);
                currentPlayerUrl = item.playerUrl || item.streamUrl || null;
                loadExternalPlayer(currentPlayerUrl, item.title);
                return;
            }
            
            urlInput.value = item.streamUrl;
            currentStreamUrl = item.streamUrl;
            currentPlayerUrl = item.playerUrl || null;
            currentEpisodeId = normalizeIdentifier(item.episodeId || item.streamUrl || item.playerUrl || item.anrollUrl);
            if (item.anrollUrl) {
                anrollInput.value = item.anrollUrl;
            }
            currentSourceUrl = item.anrollUrl || null;
            // Definir t√≠tulo do hist√≥rico, mas loadVideo() vai verificar a URL e atualizar se necess√°rio
            currentTitle = item.title;
            
            // Atualizar display do t√≠tulo temporariamente
            if (currentTitle) {
                episodeTitleDiv.textContent = currentTitle;
                episodeTitleDiv.style.display = 'block';
            } else {
                episodeTitleDiv.style.display = 'none';
            }
            
            const resumeTime = item.currentTime || 0;
            
            // loadVideo() vai atualizar o t√≠tulo baseado na URL atual se necess√°rio
            loadVideo();
            
            // Aguardar o v√≠deo carregar e ent√£o pular para o tempo salvo
            const seekToTime = () => {
                if (video.readyState >= 2 && video.duration) {
                    video.currentTime = resumeTime;
                    video.play();
                } else {
                    setTimeout(seekToTime, 100);
                }
            };
            
            video.addEventListener('loadedmetadata', seekToTime, { once: true });
            video.addEventListener('canplay', seekToTime, { once: true });
        }

        function playFromStart(index) {
            const item = window.historyData[index];
            if (!item) return;
            showHlsPlayer();
            if (item.playerType && item.playerType !== 'hls') {
                if (item.anrollUrl) {
                    anrollInput.value = item.anrollUrl;
                }
                currentSourceUrl = item.anrollUrl || null;
                currentEpisodeId = normalizeIdentifier(item.episodeId || item.playerUrl || item.streamUrl || item.anrollUrl);
                currentPlayerUrl = item.playerUrl || item.streamUrl || null;
                loadExternalPlayer(currentPlayerUrl, item.title);
                return;
            }
            
            urlInput.value = item.streamUrl;
            currentStreamUrl = item.streamUrl;
            currentPlayerUrl = item.playerUrl || null;
            currentEpisodeId = normalizeIdentifier(item.episodeId || item.streamUrl || item.playerUrl || item.anrollUrl);
            if (item.anrollUrl) {
                anrollInput.value = item.anrollUrl;
            }
            currentSourceUrl = item.anrollUrl || null;
            currentTitle = item.title;
            loadVideo();
        }

        // Atualizar informa√ß√µes periodicamente (backup caso timeupdate n√£o funcione)
        setInterval(updateVideoInfo, 250);
        
        // Atualizar em tempo real com evento do v√≠deo (mais preciso)
        video.addEventListener('timeupdate', updateVideoInfo);
        
        // Bot√£o para marcar como assistido
        markWatchedBtn.addEventListener('click', async () => {
            if (!currentEpisodeId) {
                showStatus('Nenhum v√≠deo carregado', 'error');
                return;
            }
            if (externalPlayerActive) {
                showStatus('N√£o √© poss√≠vel marcar automaticamente um player externo.', 'warning');
                return;
            }
            
            const entry = {
                streamUrl: currentStreamUrl,
                playerUrl: currentPlayerUrl,
                title: currentTitle || urlInput.value || 'Epis√≥dio',
                currentTime: video.currentTime || 0,
                duration: video.duration || 0,
                anrollUrl: currentSourceUrl || null,
                watched: true,
                episodeId: normalizeIdentifier(currentEpisodeId),
                playerType: externalPlayerActive ? 'blogger' : 'hls'
            };

            try {
                await fetch('/api/history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(entry)
                });
                loadHistory();
                markWatchedBtn.classList.add('active');
                showStatus('Epis√≥dio marcado como assistido! ‚úì', 'success');
            } catch (error) {
                console.error('Erro ao marcar como assistido:', error);
                showStatus('Erro ao marcar como assistido', 'error');
            }
        });
        
        // Verificar se o v√≠deo atual j√° est√° marcado como assistido
        function checkWatchedStatus() {
            if (!currentEpisodeId || !window.historyData) return;
            const normalizedId = normalizeIdentifier(currentEpisodeId);
            const currentItem = window.historyData.find(h => normalizeIdentifier(h.episodeId || h.streamUrl || h.playerUrl) === normalizedId);
            if (currentItem && currentItem.watched) {
                markWatchedBtn.classList.add('active');
            } else {
                markWatchedBtn.classList.remove('active');
            }
        }
        
        // Sobrescrever loadHistory para verificar status
        const originalLoadHistory = loadHistory;
        loadHistory = async function() {
            await originalLoadHistory();
            checkWatchedStatus();
        };

        // Controle de progresso
        let isDraggingProgress = false;
        
        progressSlider.addEventListener('mousedown', () => {
            isDraggingProgress = true;
        });
        
        progressSlider.addEventListener('mouseup', () => {
            if (isDraggingProgress && video.duration) {
                const newTime = (progressSlider.value / 100) * video.duration;
                video.currentTime = newTime;
            }
            isDraggingProgress = false;
        });
        
        progressSlider.addEventListener('mouseleave', () => {
            if (isDraggingProgress) {
                isDraggingProgress = false;
            }
        });
        
        progressSlider.addEventListener('input', () => {
            if (isDraggingProgress && video.duration) {
                const newTime = (progressSlider.value / 100) * video.duration;
                video.currentTime = newTime;
                currentTimeDisplay.textContent = formatTime(newTime);
            } else if (video.duration) {
                // Preview ao arrastar
                const previewTime = (progressSlider.value / 100) * video.duration;
                currentTimeDisplay.textContent = formatTime(previewTime);
            }
        });

        // Controles de m√≠dia
        rewindBtn.addEventListener('click', () => {
            video.currentTime = Math.max(0, video.currentTime - 10);
        });

        forwardBtn.addEventListener('click', () => {
            video.currentTime = Math.min(video.duration, video.currentTime + 10);
        });

        playPauseBtn.addEventListener('click', () => {
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        });

        // Atualizar √≠cone do bot√£o play/pause
        video.addEventListener('play', () => {
            playPauseBtn.textContent = '‚è∏Ô∏è';
            playPauseBtn.title = 'Pausar';
        });

        video.addEventListener('pause', () => {
            playPauseBtn.textContent = '‚ñ∂Ô∏è';
            playPauseBtn.title = 'Play';
        });

        // Controle de volume
        let previousVolume = 1;
        muteBtn.addEventListener('click', () => {
            if (video.muted) {
                video.muted = false;
                video.volume = previousVolume;
                volumeSlider.value = previousVolume * 100;
                muteBtn.textContent = 'üîä';
                muteBtn.title = 'Mutar';
            } else {
                previousVolume = video.volume;
                video.muted = true;
                volumeSlider.value = 0;
                muteBtn.textContent = 'üîá';
                muteBtn.title = 'Desmutar';
            }
        });

        volumeSlider.addEventListener('input', (e) => {
            video.volume = e.target.value / 100;
            video.muted = false;
            if (video.volume > 0) {
                previousVolume = video.volume;
                muteBtn.textContent = 'üîä';
                muteBtn.title = 'Mutar';
            } else {
                muteBtn.textContent = 'üîá';
                muteBtn.title = 'Desmutar';
            }
        });

        video.addEventListener('volumechange', () => {
            if (!video.muted) {
                volumeSlider.value = video.volume * 100;
            }
        });

        // Controle de qualidade
        function updateQualityMenu() {
            if (!hls || !hls.levels || hls.levels.length === 0) {
                qualityMenu.innerHTML = '<div class="quality-option">Nenhuma qualidade dispon√≠vel</div>';
                qualityBtn.textContent = '‚öôÔ∏è Qualidade';
                return;
            }

            const currentLevel = hls.currentLevel;
            let menuHTML = '<div class="quality-option" data-quality="-1">Auto</div>';
            
            hls.levels.forEach((level, index) => {
                const height = level.height || '?';
                const bitrate = level.bitrate ? `${Math.round(level.bitrate / 1000)}kbps` : '';
                const label = height !== '?' ? `${height}p${bitrate ? ` (${bitrate})` : ''}` : `N√≠vel ${index}`;
                const isActive = currentLevel === index ? 'active' : '';
                menuHTML += `<div class="quality-option ${isActive}" data-quality="${index}">${label}</div>`;
            });

            qualityMenu.innerHTML = menuHTML;

            // Atualizar texto do bot√£o
            if (currentLevel >= 0 && currentLevel < hls.levels.length) {
                const currentLevelObj = hls.levels[currentLevel];
                const height = currentLevelObj.height || '?';
                const label = height !== '?' ? `${height}p` : 'Auto';
                qualityBtn.textContent = `‚öôÔ∏è ${label}`;
            } else {
                qualityBtn.textContent = '‚öôÔ∏è Auto';
            }

            // Adicionar event listeners
            qualityMenu.querySelectorAll('.quality-option').forEach(option => {
                option.addEventListener('click', () => {
                    const quality = parseInt(option.dataset.quality);
                    if (hls) {
                        hls.currentLevel = quality;
                        updateQualityMenu();
                        qualityMenu.style.display = 'none';
                    }
                });
            });
        }

        // Toggle menu de qualidade
        qualityBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (hls && hls.levels && hls.levels.length > 0) {
                qualityMenu.style.display = qualityMenu.style.display === 'none' ? 'block' : 'none';
            } else {
                showStatus('Nenhuma qualidade dispon√≠vel', 'warning');
            }
        });

        // Fechar menu ao clicar fora
        document.addEventListener('click', (e) => {
            if (!qualityMenu.contains(e.target) && e.target !== qualityBtn) {
                qualityMenu.style.display = 'none';
            }
        });

        // Fullscreen
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                const container = document.querySelector('.video-container');
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        });

        // Atualizar √≠cone do fullscreen
        document.addEventListener('fullscreenchange', updateFullscreenIcon);
        document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
        document.addEventListener('msfullscreenchange', updateFullscreenIcon);

        function updateFullscreenIcon() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Sair da tela cheia';
            } else {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Tela cheia';
            }
        }

        // Atalhos de teclado
        document.addEventListener('keydown', (e) => {
            // Ignorar se estiver digitando em um input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case ' ':
                case 'k':
                    e.preventDefault();
                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    video.currentTime = Math.max(0, video.currentTime - 10);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    video.currentTime = Math.min(video.duration, video.currentTime + 10);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    video.volume = Math.min(1, video.volume + 0.1);
                    volumeSlider.value = video.volume * 100;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    video.volume = Math.max(0, video.volume - 0.1);
                    volumeSlider.value = video.volume * 100;
                    break;
                case 'm':
                    e.preventDefault();
                    video.muted = !video.muted;
                    if (video.muted) {
                        muteBtn.textContent = 'üîá';
                    } else {
                        muteBtn.textContent = 'üîä';
                    }
                    break;
                case 'f':
                    e.preventDefault();
                    fullscreenBtn.click();
                    break;
            }
        });

        // Fun√ß√£o para carregar automaticamente o √∫ltimo epis√≥dio
        async function loadLastEpisode() {
            try {
                const response = await fetch('/api/history');
                const history = await response.json();
                
                if (history && history.length > 0) {
                    const lastEpisode = history[0]; // J√° est√° ordenado por data (mais recente primeiro)
                    
                    // Preencher os campos
                    showHlsPlayer();
                    if (lastEpisode.playerType && lastEpisode.playerType !== 'hls') {
                        if (lastEpisode.anrollUrl) {
                            anrollInput.value = lastEpisode.anrollUrl;
                        }
                        currentSourceUrl = lastEpisode.anrollUrl || null;
                        currentPlayerUrl = lastEpisode.playerUrl || lastEpisode.streamUrl;
                        currentEpisodeId = normalizeIdentifier(lastEpisode.episodeId || currentPlayerUrl);
                        loadExternalPlayer(currentPlayerUrl, lastEpisode.title);
                        return;
                    }
                    if (lastEpisode.anrollUrl) {
                        anrollInput.value = lastEpisode.anrollUrl;
                    }
                    currentSourceUrl = lastEpisode.anrollUrl || null;
                    urlInput.value = lastEpisode.streamUrl;
                    currentStreamUrl = lastEpisode.streamUrl;
                     currentPlayerUrl = lastEpisode.playerUrl || null;
                     currentEpisodeId = normalizeIdentifier(lastEpisode.episodeId || lastEpisode.streamUrl || lastEpisode.playerUrl);
                    currentTitle = lastEpisode.title;
                    
                    // Atualizar display do t√≠tulo
                    if (currentTitle) {
                        episodeTitleDiv.textContent = currentTitle;
                        episodeTitleDiv.style.display = 'block';
                    } else {
                        episodeTitleDiv.style.display = 'none';
                    }
                    
                    // Carregar o v√≠deo
                    loadVideo();
                    
                    // Aguardar o v√≠deo carregar e pular para o tempo salvo
                    const seekToLastPosition = () => {
                        if (video.readyState >= 2 && video.duration) {
                            const resumeTime = lastEpisode.currentTime || 0;
                            video.currentTime = resumeTime;
                            showStatus(`Retomando de onde parou: ${formatTime(resumeTime)}`, 'info');
                        } else {
                            setTimeout(seekToLastPosition, 100);
                        }
                    };
                    
                    video.addEventListener('loadedmetadata', seekToLastPosition, { once: true });
                    video.addEventListener('canplay', seekToLastPosition, { once: true });
                }
            } catch (error) {
                console.error('Erro ao carregar √∫ltimo epis√≥dio:', error);
            }
        }

        // Carregar hist√≥rico ao iniciar
        loadHistory();

        // Carregar automaticamente o √∫ltimo epis√≥dio
        loadLastEpisode();

        // Salvar progresso quando o v√≠deo for pausado ou fechado
        video.addEventListener('pause', saveProgress);
        video.addEventListener('ended', saveProgress);
        window.addEventListener('beforeunload', saveProgress);
    </script>
</body>
</html>
